use std::{path::Path, str::FromStr};

use solana_program::{native_token::LAMPORTS_PER_SOL, pubkey::Pubkey, system_program};
use solana_rpc_client_api::config::RpcRequestAirdropConfig;
use solana_sdk::{
    account::Account,
    signature::{read_keypair_file, Keypair, Signer},
};
use sov_stf_runner::processes::RollupProverConfig;
use svm::test_utils::prepare_new_account_transaction;
use svm_rollup::zk::InnerZkvm;
use svm_test_helper::{start_node, TEST_GENESIS_CONFIG_DIR};

use crate::{
    svm::{svm_test_helper, test_client::TestClient},
    test_helpers::get_appropriate_rollup_prover_config,
};

const SLEEP_TIME: u64 = 150 * 25;

#[tokio::test(flavor = "multi_thread")]
async fn svm_tx_tests_instant_finality() -> anyhow::Result<()> {
    let rollup_prover_config = get_appropriate_rollup_prover_config();
    test_svm_rpc_endpoints(0, rollup_prover_config).await
}

async fn test_svm_rpc_endpoints(
    finalization_blocks: u32,
    rollup_prover_config: RollupProverConfig<InnerZkvm>,
) -> anyhow::Result<()> {
    let test_rollup = start_node(rollup_prover_config, finalization_blocks).await;
    let da_service = test_rollup.da_service.clone();
    da_service.produce_n_blocks_now(3).await?;
    // Sleep for a bit to allow the node to start up and avoid a sequencer bug
    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    let test_client = svm_test_helper::create_test_client(test_rollup.http_addr).await;

    // Test autogenerated rpc endpoints for SVM module
    test_svm_rpc_methods(&test_client)
        .await
        .expect("Failed to interact with SVM module rpc endpoints");

    // Test manually set sequencer's (SvmNode) rpc endpoints
    test_publish_solana_transaction(&test_client)
        .await
        .expect("Failed to submit and publish a transaction to DA");

    test_request_airdrop(&test_client)
        .await
        .expect("Failed to request an airdrop");

    test_rollup.rollup_task.abort();
    Ok(())
}

#[allow(dead_code)]
async fn test_svm_rpc_methods(test_client: &TestClient) -> Result<(), Box<dyn std::error::Error>> {
    // Test query_state() rpc method to check basic query response
    let svm_state = test_client.svm_query_state().await;
    assert_eq!(
        svm_state,
        "Hello".to_string(),
        "Expected SVM state to be 'Hello'"
    );

    // Test get_slot() rpc method to check that can query SVM state
    let svm_slot = test_client.svm_get_slot().await;
    assert!(svm_slot > 0, "Expected an epoch slot greater than 0");

    // During genesis we initialized two solana accounts from svm.json config
    // Test get_account_info() rpc method to check first initialized account state
    let expected_account_info = Account {
        lamports: 2_500_000,
        owner: system_program::id(),
        data: Vec::new(),
        executable: false,
        rent_epoch: 123,
    };
    let test_account_info = test_client
        .svm_get_account_info(
            Pubkey::from_str("6v3trJvARm9B4P7ge4FYYDL2GtPtRrvF2rQfVNndfr7e")
                .expect("Failed to parse pubkey"),
        )
        .await;
    assert_eq!(
        test_account_info, expected_account_info,
        "Expected to retrieve account set in svm.json config"
    );

    // Test get_balance() RPC method to check second initialized account state
    let expected_balance: u64 = 2_500_000;
    let test_balance = test_client
        .svm_get_account_balance(
            Pubkey::from_str("Fv5rsJKREP59UrUH3GqA3dgmjFZiPWj35ELSitAE1i37")
                .expect("Failed to parse pubkey"),
        )
        .await;
    assert_eq!(
        test_balance, expected_balance,
        "Expected account balance to be 100_000 lamports"
    );

    let tx_count = test_client.svm_get_transaction_count().await;
    assert_eq!(tx_count, 0, "Expected transaction count to be 0");

    Ok(())
}

async fn test_publish_solana_transaction(
    client: &TestClient,
) -> Result<(), Box<dyn std::error::Error>> {
    // Note: These accounts are not initialized in the SVM module's state
    let path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .join(TEST_GENESIS_CONFIG_DIR)
        .join("keypairs/2MCVmcuUcREwQKDS3HazuYctkkbZV3XRMspM5eLWRZUV-keypair.json");
    let payer = read_keypair_file(path).expect("Failed to read payer keypair");
    let test_account = Keypair::new();

    // Retrieves the latest blockhash registered in SVM module's state which is set during genesis
    let recent_blockhash = client.svm_get_latest_blockhash().await;

    // Create and serialize a signed solana transaction for test
    let test_sol_tx = prepare_new_account_transaction(
        &payer,
        &test_account,
        LAMPORTS_PER_SOL / 2,
        recent_blockhash,
    );

    // Try sending transaction to a sequencer's storage
    let test_tx_signature = client.svm_send_transaction(&test_sol_tx).await;
    let expected_tx_signature = test_sol_tx.signatures[0];
    assert_eq!(
        test_tx_signature, expected_tx_signature,
        "Transaction signatures do not match"
    );

    tokio::time::sleep(std::time::Duration::from_millis(SLEEP_TIME)).await;
    let balance = client.svm_get_account_balance(test_account.pubkey()).await;
    assert_eq!(LAMPORTS_PER_SOL / 2, balance);

    let tx_count = client.svm_get_transaction_count().await;
    assert_eq!(tx_count, 1, "Expected transaction count to be 1");

    Ok(())
}

async fn test_request_airdrop(client: &TestClient) -> Result<(), Box<dyn std::error::Error>> {
    let test_receiver = Pubkey::from_str("6v3trJvARm9B4P7ge4FYYDL2GtPtRrvF2rQfVNndfr7e")
        .expect("Failed to parse pubkey");
    let balance = client.svm_get_account_balance(test_receiver).await;
    assert_eq!(2_500_000, balance);

    // Retrieves the latest blockhash registered in SVM module's state which is set during genesis
    let blockhash = client.svm_get_latest_blockhash().await;
    let config = Some(RpcRequestAirdropConfig {
        recent_blockhash: Some(blockhash.to_string()),
        commitment: None,
    });

    // should error because requested amount is over the limit
    assert!(client
        .svm_request_airdrop(&test_receiver, 500_000, config.clone())
        .await
        .is_err());

    assert!(client
        .svm_request_airdrop(&test_receiver, 50, config.clone())
        .await
        .is_ok());

    tokio::time::sleep(std::time::Duration::from_millis(SLEEP_TIME)).await;
    let balance = client.svm_get_account_balance(test_receiver).await;
    assert_eq!(2_500_000 + 50, balance);

    // should error because airdrop requested is rate limited per account
    assert!(client
        .svm_request_airdrop(&test_receiver, 500, config)
        .await
        .is_err());

    // Test airdrop for a new account
    let test_receiver = Keypair::new();

    // Retrieves the latest blockhash registered in SVM module's state which is set during genesis
    let blockhash = client.svm_get_latest_blockhash().await;
    let config = Some(RpcRequestAirdropConfig {
        recent_blockhash: Some(blockhash.to_string()),
        commitment: None,
    });

    client
        .svm_request_airdrop(&test_receiver.pubkey(), 50, config.clone())
        .await?;

    tokio::time::sleep(std::time::Duration::from_millis(SLEEP_TIME)).await;

    let balance = client.svm_get_account_balance(test_receiver.pubkey()).await;
    let rent_exemption_balance = client.svm_get_minimum_balance_for_rent_exemption(0).await;
    assert_eq!(rent_exemption_balance + 50, balance);

    let tx_count = client.svm_get_transaction_count().await;
    assert_eq!(tx_count, 3, "Expected transaction count to be 3");

    Ok(())
}
