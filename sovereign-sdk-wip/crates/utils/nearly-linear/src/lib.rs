//! This crates provides support for a limited form of `linear` types (i.e. types that must be used exactly once) in Rust
//! The support is "limited" because we cannot guarantee that a type will be used during unwinding. `drop` calls
//! that are automatically generated by Rustc as part of stack unwinding`during a panic are excluded from the analysis
//! done by this crate.
//!
//! This crate requires a custom lint which can be obtained here: <https://github.com/Sovereign-Labs/sdk-lints>.
//!
//! ## Using the lint
//! 1. install the `dylint` linter:
//! ```bash
//! cargo +stable install cargo-dylint dylint-link
//! ```
//! 2. Add the lint to your project's Cargo.toml:
//! ```toml
//! [workspace.metadata.dylint]
//! libraries = [
//!    { git = "ssh://git@github.com/Sovereign-Labs/sdk-lints.git" },
//! ]
//! ```
//!
//! 3. Run the linter:
//! ```bash
//! cargo dylint --all
//! ```

// #![deny(clippy::suspicious)]
use std::ops::{Deref, DerefMut};

/// Implementing this trait causes the type to warn when dropped under this `dylint` lint: <https://github.com/Sovereign-Labs/sdk-lints>.
/// See the module-level docs for more information.
///
/// In general, you should just use `DropGuard` instead of implementing this trait.
// Note on `#[allow(drop_bounds)]`: We really do want a Drop bound here because the lint works by searching for
// drop(T) in the MIR. If at type is not `Drop`, these calls may be absent leading to false negatives.
//
// In other words, we really do want to check that the type implements `Drop` and not that it can be trivially dropped.
#[allow(drop_bounds)]
pub trait DropWarning: Drop {
    /// The inner type that must be used.
    type Inner;
    /// Consume the `DropWarning` and return the inner type. This is an "escape hatch" which indicates that
    /// the value is now safe to drop - note that this is cannot be checked by the `clippy` extension, so incorrect usages
    /// will break the linearity property.
    fn done(self) -> Self::Inner;
}

/// A union of `DropGuard<T>` and `T`. Since `DropGuard<T>` is `repr(transparent)`, these types have the same memory layout.
union DropGuardHelper<T> {
    drop_guard: std::mem::ManuallyDrop<DropGuard<T>>,
    contents: std::mem::ManuallyDrop<T>,
}

/// A type that warns when dropped, unless the drop occurs in cleanup code after a panic.
#[repr(transparent)]
pub struct DropGuard<T>(T);

impl<T> DropGuard<T> {
    pub fn new(item: T) -> Self {
        Self(item)
    }
}

impl<T> Deref for DropGuard<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

impl<T> DerefMut for DropGuard<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

// The clippy extension works by looking for calls to `drop` in the MIR.
// If the inner type doesn't implement `Drop`, this call would be missing causing false negatives -
// so we implement `Drop` on the `DropGuard` to ensure that the check is present.
impl<T> Drop for DropGuard<T> {
    fn drop(&mut self) {
        // Do nothing
    }
}

impl<T: Sized> DropWarning for DropGuard<T> {
    type Inner = T;
    fn done(self) -> T {
        let as_union = DropGuardHelper {
            drop_guard: std::mem::ManuallyDrop::new(self),
        };
        std::mem::ManuallyDrop::into_inner(
            // Safety: Since we use repr(transparent), `DropGuard<T>` is
            // guaranteed to be bit-for-bit identical to the underlying `T`.
            unsafe { as_union.contents },
        )
    }
}
