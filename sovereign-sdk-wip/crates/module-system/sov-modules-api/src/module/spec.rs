//! Module specification definitions.

use core::fmt::Debug;

use borsh::{BorshDeserialize, BorshSerialize};
use sov_rollup_interface::crypto::{CredentialId, Signature};
use sov_rollup_interface::da::DaSpec;
use sov_rollup_interface::optimistic::Attestation;
use sov_rollup_interface::zk::{CryptoSpec, StateTransitionPublicData, Zkvm};
use sov_rollup_interface::BasicAddress;
use sov_state::{Storage, StorageProof, Witness};

use crate::gas::Gas;
use crate::higher_kinded_types::Generic;
use crate::transaction::Credentials;
use crate::{PublicKeyExt, SignatureExt};

/// The `Spec` trait configures certain key primitives to be used by a by a particular instance of a rollup.
/// `Spec` is almost always implemented on a Context object; since all Modules are generic
/// over a Context, rollup developers can easily optimize their code for different environments
/// by simply swapping out the Context (and by extension, the Spec).
///
/// For example, a rollup running in a STARK-based zkVM like Risc0 might pick Sha256 or Poseidon as its preferred hasher,
/// while a rollup running in an elliptic-curve based SNARK such as `Placeholder` from the =nil; foundation might
/// prefer a Pedersen hash. By using a generic Spec, a rollup developer can trivially customize their
/// code for either (or both!) of these environments without touching their module implementations.
pub trait Spec:
    BorshDeserialize
    + BorshSerialize
    + Default
    + Debug
    + Clone
    + Send
    + Sync
    + PartialEq
    + Eq
    + Generic
    + 'static
{
    /// The DA specification used by the rollup.
    type Da: DaSpec;

    /// Gas unit for the gas price computation.
    type Gas: Gas;

    /// The Address type used on the rollup. Typically calculated as the hash of a public key.
    ///
    /// # Security
    /// It is crucial that the Address type is *not* an arbitrary user-controlled value. At the very least,
    /// addresses should be fixed-width types.
    ///
    /// Ideally, a 20-64 byte array with a sensible encoding (base58, bech32) should
    /// be used. If adversaries can craft addresses with enough freedom, they may be able to create collisions among the FromStr
    /// representations of nested state values. While this should not cause any critical harm, it may make portions of your rollup
    /// unqueryable via JSON APIs - and other more pernicious vulnerabilities may be lurking.
    /// In addition, please use extreme caution if "/" is a valid character in your address charset since "/" is reserved as a
    /// domain separator in paths generated by the SDK.
    #[cfg(feature = "native")]
    type Address: BasicAddress + From<CredentialId> + Sync;

    /// The Address type used on the rollup. Typically calculated as the hash of a public key.
    #[cfg(not(feature = "native"))]
    type Address: BasicAddress + From<CredentialId>;

    /// Authenticated state storage used by the rollup. Typically some variant of a merkle-patricia trie.
    #[cfg(not(feature = "native"))]
    type Storage: Storage + Send + Sync;

    /// Authenticated state storage used by the rollup. Typically some variant of a merkle-patricia trie.
    #[cfg(feature = "native")]
    type Storage: Storage + sov_state::NativeStorage + Send + Sync;

    /// The Zkvm which verifies the inner circuit, where
    /// the `inner` circuit proves the correctness of the state transition for individual DA blocks.
    type InnerZkvm: Zkvm;

    /// The Zkvm which verifies the outer circuit, where
    /// the `outer` circuit proves the correctness of the state transition for the whole chain since genesis.
    type OuterZkvm: Zkvm;

    /// The cryptographic primitives used by the rollup.
    type CryptoSpec: CryptoSpecExt;

    /// A structure containing the non-deterministic inputs from the prover to the zk-circuit
    type Witness: Witness;
}

/// A helper trait which is blanket implemented for all `CryptoSpec` types that
/// are also compatible with module system requirements. This helper works around the lack of implied bounds in Rustc.
/// See <https://github.com/rust-lang/rust/issues/121325> for details.
#[cfg(not(feature = "native"))]
pub trait CryptoHelper:
    CryptoSpec<Signature = Self::ExtendedSignature, PublicKey = Self::ExtendedPublicKey>
{
    /// The digital signature scheme used by the rollup.
    type ExtendedSignature: SignatureExt + Signature<PublicKey = Self::ExtendedPublicKey>;

    /// The public key used for digital signatures
    type ExtendedPublicKey: PublicKeyExt;
}

/// A helper trait which is blanket implemented for all `CryptoSpec` types that
/// are also compatible with module system requirements. This helper works around the lack of implied bounds in Rustc.
/// See <https://github.com/rust-lang/rust/issues/121325> for details.
#[cfg(feature = "native")]
pub trait CryptoHelper:
    CryptoSpec<
    Signature = Self::ExtendedSignature,
    PublicKey = Self::ExtendedPublicKey,
    PrivateKey = Self::ExtendedPrivateKey,
>
{
    /// The digital signature scheme used by the rollup.
    type ExtendedSignature: SignatureExt + Signature<PublicKey = Self::ExtendedPublicKey>;

    /// The public key used for digital signatures
    type ExtendedPublicKey: PublicKeyExt;

    /// The private key used for digital signatures
    type ExtendedPrivateKey: crate::PrivateKeyExt<
        PublicKey = Self::ExtendedPublicKey,
        Signature = Self::ExtendedSignature,
    >;
}

/// An extension trait for a `CryptoSpec` which guarantees that the type implements the
/// slightly more restrictive traits defined in the module system.
pub trait CryptoSpecExt: CryptoHelper {}

#[cfg(feature = "native")]
impl<C: CryptoSpec> CryptoHelper for C
where
    C::Signature: SignatureExt,
    C::PublicKey: PublicKeyExt,
    C::PrivateKey: crate::PrivateKeyExt,
{
    type ExtendedPrivateKey = C::PrivateKey;
    type ExtendedSignature = C::Signature;
    type ExtendedPublicKey = C::PublicKey;
}

#[cfg(not(feature = "native"))]
impl<C: CryptoSpec> CryptoHelper for C
where
    C::Signature: SignatureExt,
    C::PublicKey: PublicKeyExt,
{
    type ExtendedPublicKey = C::PublicKey;
    type ExtendedSignature = C::Signature;
}

/// An extension trait for a `CryptoSpec` which guarantees that the type implements the
/// slightly more restrictive traits defined in the module system.
impl<C: CryptoHelper> CryptoSpecExt for C {}

/// The context in which a transaction executes

#[derive(Clone, Debug)]
pub struct Context<S: Spec> {
    /// The original credentials of the sender.
    sender_credentials: Credentials,
    /// The sender address of the transaction.
    sender: S::Address,
    /// The rollup address of the sequencer who included the transaction.
    sequencer: S::Address,
    /// The DA layer address of the sequencer who included the transaction.
    sequencer_da_address: <S::Da as DaSpec>::Address,
    /// The rollup address that pays the gas fees for the transaction.
    gas_refund_recipient: S::Address,
}

impl<S: Spec> Context<S> {
    /// Returns the rollup address which sent the transaction.
    pub fn sender(&self) -> &S::Address {
        &self.sender
    }

    /// Returns the rollup address of the sequencer which included the transaction.
    pub fn sequencer(&self) -> &S::Address {
        &self.sequencer
    }

    /// Returns the DA layer address of the sequencer which included the transaction.
    pub fn sequencer_da_address(&self) -> &<S::Da as DaSpec>::Address {
        &self.sequencer_da_address
    }

    /// Returns the rollup address which will receive any gas refund from the transaction.
    pub fn gas_refund_recipient(&self) -> &S::Address {
        &self.gas_refund_recipient
    }

    /// Updates the rollup address which will receive any gas refund from the transaction.
    pub fn set_gas_refund_recipient(&mut self, recipient: S::Address) {
        self.gas_refund_recipient = recipient;
    }

    /// Constructs a new Context with the provided sender as the payer.
    pub fn new(
        sender: S::Address,
        sender_credentials: Credentials,
        sequencer: S::Address,
        sequencer_da_address: <S::Da as DaSpec>::Address,
    ) -> Self {
        Self::with_payer(
            sender.clone(),
            sender_credentials,
            sequencer,
            sequencer_da_address,
            sender,
        )
    }

    /// Constructs a new Context with the provided payer.
    pub fn with_payer(
        sender: S::Address,
        sender_credentials: Credentials,
        sequencer: S::Address,
        sequencer_da_address: <S::Da as DaSpec>::Address,
        payer: S::Address,
    ) -> Self {
        Self {
            sender_credentials,
            sender,
            sequencer,
            sequencer_da_address,
            gas_refund_recipient: payer,
        }
    }

    /// Returns the sender's credentials.
    pub fn get_sender_credential<T: core::any::Any>(&self) -> Option<&T> {
        self.sender_credentials.get::<T>()
    }
}

/// Simplified type alias for `Attestation`
pub type SovAttestation<S> = Attestation<
    <<S as Spec>::Da as DaSpec>::SlotHash,
    <<S as Spec>::Storage as Storage>::Root,
    StorageProof<<<S as Spec>::Storage as Storage>::Proof>,
>;

/// Simplified type alias for `StateTransitionPublicData`
pub type SovStateTransitionPublicData<S> = StateTransitionPublicData<
    <S as Spec>::Address,
    <S as Spec>::Da,
    <<S as Spec>::Storage as Storage>::Root,
>;

#[cfg(feature = "arbitrary")]
mod arbitrary {
    use ::arbitrary::{Arbitrary, Unstructured};
    use sov_rollup_interface::da::DaSpec;

    use super::{Context, Spec};

    impl<'a, S> Arbitrary<'a> for Context<S>
    where
        S: Spec,
        S::Address: Arbitrary<'a>,
        <S::Da as DaSpec>::Address: Arbitrary<'a>,
    {
        fn arbitrary(u: &mut Unstructured<'a>) -> ::arbitrary::Result<Self> {
            let sender = u.arbitrary()?;
            let sequencer = u.arbitrary()?;
            let sequencer_da_address = u.arbitrary()?;

            Ok(Self::new(
                sender,
                Default::default(),
                sequencer,
                sequencer_da_address,
            ))
        }
    }
}
