use celestia_types::nmt::Namespace;

use crate::types::APP_VERSION;
use crate::verifier::address::CelestiaAddress;
use crate::verifier::RollupParams;

pub const ROLLUP_BATCH_NAMESPACE: Namespace = Namespace::const_v0(*b"\0\0sov-test");
pub const ROLLUP_PROOF_NAMESPACE: Namespace = Namespace::const_v0(*b"sov-test-p");

// Used for synthetically produced blocks
pub const ROLLUP_PARAMS_DEV: RollupParams = RollupParams {
    rollup_batch_namespace: ROLLUP_BATCH_NAMESPACE,
    rollup_proof_namespace: ROLLUP_PROOF_NAMESPACE,
};

const ROLLUP_OTHER_NAMESPACE_PRECEDING: Namespace = Namespace::const_v0(*b"\0\0sov-aaaa");
const ROLLUP_OTHER_NAMESPACE_FOLLOWING: Namespace = Namespace::const_v0(*b"\0\0sov-zzzz");

pub const ADDR_1: &str = "celestia1a68m2l85zn5xh0l07clk4rfvnezhywc53g8x7s";
pub const ADDR_2: &str = "celestia1hvp2nfz3r6nqt8mlrzqf9ctwle942tkr0wql75";
pub const ADDR_3: &str = "celestia1w7wcupk5gswj25c0khnkey5fwmlndx6t5aarmk";
// One of the "mocha" addresses
pub const ADDR_4: &str = "celestia1vfpr5g7gfxawjdy0snrjku058vc8amumr29str";

pub(crate) fn raw_blob_from_data(
    namespace: Namespace,
    data: Vec<u8>,
    signer: &CelestiaAddress,
) -> anyhow::Result<celestia_types::blob::RawBlob> {
    Ok(celestia_types::blob::RawBlob::from(
        celestia_types::blob::Blob::new_with_signer(
            namespace,
            data,
            signer.0.clone(),
            APP_VERSION,
        )?,
    ))
}

pub(crate) mod files {
    use std::fs::File;
    use std::path::{Path, PathBuf};

    use anyhow::Context;
    use celestia_rpc::{HeaderClient, ShareClient, StateClient};
    use celestia_types::blob::RawBlob;
    use celestia_types::nmt::Namespace;
    use celestia_types::row_namespace_data::NamespaceData;
    use celestia_types::ExtendedHeader;
    use rand::{RngCore, SeedableRng};
    use serde::de::DeserializeOwned;

    use super::*;
    use crate::types::{FilteredCelestiaBlock, NamespaceRelevantData};
    use crate::verifier::RollupParams;

    // The files are generated by running the `regenerate_test_data` and `generate_synthetic_test_blocks` tests
    pub const PREV_HEADER_JSON: &str = "prev_header.json";
    pub const HEADER_JSON: &str = "header.json";
    pub const ROLLUP_BATCH_ROWS_JSON: &str = "rollup_batch_rows.json";
    pub const ROLLUP_PROOF_ROWS_JSON: &str = "rollup_proof_rows.json";
    pub const SIGNERS_JSON: &str = "signers.json";

    const ROLLUP_BATCH_NAMESPACE_EXAMPLES_RAW: [u8; 10] =
        [0, 0, 115, 111, 118, 45, 116, 101, 115, 116];
    pub const ROLLUP_BATCH_NAMESPACE_EXAMPLES: Namespace =
        Namespace::const_v0(ROLLUP_BATCH_NAMESPACE_EXAMPLES_RAW);

    /// The namespace used by the rollup to store aggregated ZK proofs.
    pub const ROLLUP_PROOF_NAMESPACE_EXAMPLES_RAW: [u8; 10] =
        [115, 111, 118, 45, 116, 101, 115, 116, 45, 112];
    pub const ROLLUP_PROOF_NAMESPACE_EXAMPLES: Namespace =
        Namespace::const_v0(ROLLUP_PROOF_NAMESPACE_EXAMPLES_RAW);

    // From `examples/const-rollup-config`. Used from blocks that were produced on devnet/testnet
    pub const ROLLUP_PARAMS_EXAMPLES: RollupParams = RollupParams {
        rollup_batch_namespace: ROLLUP_BATCH_NAMESPACE_EXAMPLES,
        rollup_proof_namespace: ROLLUP_PROOF_NAMESPACE_EXAMPLES,
    };

    /// Fits into single share.
    pub const SMALL_BATCH_BYTES: usize = 300;
    /// Fits into 3 shares.
    pub const MEDIUM_BATCH_BYTES: usize = 1200;
    /// Fits into 50 shares.
    pub const LARGE_BATCH_BYTES: usize = 25600;

    #[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
    pub(crate) struct PayloadData {
        batches: Vec<String>,
        proofs: Vec<String>,
    }

    impl PayloadData {
        pub(crate) fn batches(&self) -> Vec<Vec<u8>> {
            self.batches
                .iter()
                .map(|s| hex::decode(s).unwrap())
                .collect()
        }

        pub(crate) fn proofs(&self) -> Vec<Vec<u8>> {
            self.proofs
                .iter()
                .map(|s| hex::decode(s).unwrap())
                .collect()
        }
    }

    pub mod with_rollup_proof_data {
        use super::*;
        pub const DATA_PATH: &str = "test_data/block_with_rollup_proof_data";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub fn get_payload() -> PayloadData {
            let path = make_test_path(DATA_PATH);
            get_payload_for_test(&path).unwrap()
        }
    }

    pub mod with_rollup_batch_data {
        use super::*;

        pub const DATA_PATH: &str = "test_data/block_with_rollup_batch_data";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }
        pub fn get_payload() -> PayloadData {
            let path = make_test_path(DATA_PATH);
            get_payload_for_test(&path).unwrap()
        }
    }

    pub mod medium_from_devnet {
        use super::*;

        pub const DATA_PATH: &str = "test_data/block_with_medium_size_single_rollup_batch_data";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_EXAMPLES;

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }
    }

    pub mod with_namespace_padding {
        use super::*;
        pub const DATA_PATH: &str = "test_data/block_with_namespace_padding";
        // sov-roll05 is the demo testnet rollup that faced the padding issue
        // We use the exact mocha testnet block that caused the breakage
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub fn get_payload() -> PayloadData {
            let path = make_test_path(DATA_PATH);
            get_payload_for_test(&path).unwrap()
        }
    }

    pub mod without_rollup_batch_data {
        use super::*;
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;
        pub const DATA_PATH: &str = "test_data/block_without_rollup_batch_data";

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }
    }

    pub mod with_several_small_rollup_batches {
        use super::*;

        pub const DATA_PATH: &str = "test_data/block_with_several_small_rollup_batches";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub async fn update_test_data(
            client: &jsonrpsee::http_client::HttpClient,
            signer: &CelestiaAddress,
        ) {
            let payload = get_payload();
            let path = make_test_path(DATA_PATH);
            update_block_data_from_payload(&path, client, signer, false, payload)
                .await
                .unwrap();
        }

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub fn get_payload() -> PayloadData {
            generate_payload_with_batches(21, SMALL_BATCH_BYTES)
        }
    }

    pub mod with_several_medium_rollup_batches {
        use super::*;

        pub const DATA_PATH: &str = "test_data/block_with_several_medium_rollup_batches";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub async fn update_test_data(
            client: &jsonrpsee::http_client::HttpClient,
            signer: &CelestiaAddress,
        ) {
            let payload = get_payload();
            let path = make_test_path(DATA_PATH);
            update_block_data_from_payload(&path, client, signer, false, payload)
                .await
                .unwrap();
        }

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub fn get_payload() -> PayloadData {
            generate_payload_with_batches(11, MEDIUM_BATCH_BYTES)
        }
    }

    pub mod with_several_large_rollup_batches {
        use super::*;

        pub const DATA_PATH: &str = "test_data/block_with_several_large_rollup_batches";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub async fn update_test_data(
            client: &jsonrpsee::http_client::HttpClient,
            signer: &CelestiaAddress,
        ) {
            let payload = get_payload();
            let path = make_test_path(DATA_PATH);
            update_block_data_from_payload(&path, client, signer, false, payload)
                .await
                .unwrap();
        }

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub fn get_payload() -> PayloadData {
            generate_payload_with_batches(5, LARGE_BATCH_BYTES)
        }
    }

    pub mod with_preceding_blobs_from_different_namespaces {
        use super::*;
        pub const DATA_PATH: &str =
            "test_data/block_with_preceding_blobs_from_different_namespaces";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub async fn update_test_data(
            client: &jsonrpsee::http_client::HttpClient,
            signer: &CelestiaAddress,
        ) -> anyhow::Result<()> {
            let mut rng = rand::rngs::SmallRng::from_seed([1; 32]);
            let mut blobs: Vec<RawBlob> = Vec::new();
            let path = make_test_path(DATA_PATH);

            for namespace in &[
                ROLLUP_OTHER_NAMESPACE_PRECEDING,
                ROLLUP_OTHER_NAMESPACE_PRECEDING,
                ROLLUP_OTHER_NAMESPACE_PRECEDING,
                ROLLUP_OTHER_NAMESPACE_PRECEDING,
                ROLLUP_OTHER_NAMESPACE_PRECEDING,
                ROLLUP_OTHER_NAMESPACE_FOLLOWING,
                ROLLUP_OTHER_NAMESPACE_FOLLOWING,
                ROLLUP_OTHER_NAMESPACE_FOLLOWING,
            ] {
                let mut data = vec![0u8; SMALL_BATCH_BYTES];
                rng.fill_bytes(&mut data);
                let blob = raw_blob_from_data(*namespace, data, signer)?;
                blobs.push(blob);
            }

            for size in [SMALL_BATCH_BYTES, MEDIUM_BATCH_BYTES] {
                let mut data = vec![0u8; size];
                rng.fill_bytes(&mut data);
                let blob = raw_blob_from_data(ROLLUP_BATCH_NAMESPACE, data, signer)?;
                blobs.push(blob);
            }

            // Only last 2
            let signers = serde_json::json!({"signers": vec![signer.to_string(); 2]});
            write_to_file(&path.join(SIGNERS_JSON), &signers)?;

            let block_header = submit_blobs(client, blobs).await?;

            save_blobs(
                client,
                &path,
                &block_header,
                ROLLUP_BATCH_NAMESPACE,
                ROLLUP_PROOF_NAMESPACE,
            )
            .await;

            Ok(())
        }
    }

    pub mod with_batch_and_proof_same_block {
        use super::*;
        pub const DATA_PATH: &str = "test_data/block_with_batch_and_proof";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub async fn update_test_data(
            client: &jsonrpsee::http_client::HttpClient,
            signer: &CelestiaAddress,
        ) {
            let mut payload = generate_payload_with_batches(2, MEDIUM_BATCH_BYTES);
            let proof_payload = generate_payload_with_batches(3, MEDIUM_BATCH_BYTES);
            payload.proofs = proof_payload.batches;

            let path = make_test_path(DATA_PATH);
            update_block_data_from_payload(&path, client, signer, false, payload)
                .await
                .unwrap();
        }

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }
    }

    pub mod from_testnet {
        use super::*;
        pub const DATA_PATH: &str = "test_data/block_from_testnet";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_EXAMPLES;

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }
    }

    /// https://mocha-4.celenium.io/block/3001032?tab=transactions/
    /// https://github.com/Sovereign-Labs/sovereign-sdk-wip/issues/1755
    pub mod from_testnet_no_shares {
        use super::*;
        pub const DATA_PATH: &str = "test_data/block_mocha_no_shares";
        // Does not actually matter.
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_EXAMPLES;

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }
        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub async fn update_test_data(client: &jsonrpsee::http_client::HttpClient) {
            let path = make_test_path(DATA_PATH);
            let signers = serde_json::json!({"signers": Vec::<String>::new()});
            write_to_file(&path.join(SIGNERS_JSON), &signers).unwrap();

            let height = 3001032;
            let block_header = client.header_get_by_height(height).await.unwrap();
            save_blobs(
                client,
                &path,
                &block_header,
                ROLLUP_BATCH_NAMESPACE,
                ROLLUP_PROOF_NAMESPACE,
            )
            .await;
        }
    }

    /// Blocks that produced this error:
    /// process_next_slot{next_da_height=5813672}:StfBlueprint::apply_slot{context=Node da_height=5813672}:select_blobs_for_preferred_sequencer:
    ///   sov_blob_storage::capabilities:
    ///     Unable to deserialize blob. slashing sender if they are registered
    ///     blob_hash="f7a6296ecf81a430f225a1fa93ba083ca4636a2cb4b7deecc355217763183a29"
    ///     slashed_sender=celestia1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzf30as
    ///     error=Custom { kind: InvalidData, error: "Unexpected length of input" }
    pub mod from_testnet_with_tail_padding {
        use super::*;
        pub const DATA_PATH: &str = "test_data/block_mocha_with_tail_padding";
        // Used in test run
        const BATCH_NAMESPACE_RAW: [u8; 10] = [0, 0, 115, 111, 118, 45, 116, 101, 115, 120];
        const PROOF_NAMESPACE_RAW: [u8; 10] = [115, 111, 118, 45, 116, 101, 115, 116, 45, 114];

        pub const ROLLUP_PARAMS: RollupParams = RollupParams {
            rollup_batch_namespace: Namespace::const_v0(BATCH_NAMESPACE_RAW),
            rollup_proof_namespace: Namespace::const_v0(PROOF_NAMESPACE_RAW),
        };

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub async fn update_test_data(client: &jsonrpsee::http_client::HttpClient) {
            let path = make_test_path(DATA_PATH);

            let signers = serde_json::json!({"signers": vec![ADDR_4]});
            write_to_file(&path.join(SIGNERS_JSON), &signers).unwrap();

            let height = 5812964;
            let block_header = client.header_get_by_height(height).await.unwrap();
            save_blobs(
                client,
                &path,
                &block_header,
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
            )
            .await;
        }
    }

    pub mod with_mixed_v0_and_v1_blobs {
        use super::*;
        pub const DATA_PATH: &str = "test_data/block_with_mixed_v0_v1_batches";
        pub const ROLLUP_PARAMS: RollupParams = ROLLUP_PARAMS_DEV;

        pub fn filtered_block() -> FilteredCelestiaBlock {
            let path = make_test_path(DATA_PATH);
            filtered_block_from_path(
                ROLLUP_PARAMS.rollup_batch_namespace,
                ROLLUP_PARAMS.rollup_proof_namespace,
                &path,
            )
            .unwrap()
        }

        pub fn test_case() -> (FilteredCelestiaBlock, RollupParams, Vec<CelestiaAddress>) {
            (filtered_block(), ROLLUP_PARAMS, read_signers(DATA_PATH))
        }

        pub async fn update_test_data(
            client: &jsonrpsee::http_client::HttpClient,
            signer: &CelestiaAddress,
        ) {
            let path = make_test_path(DATA_PATH);
            let mut rng = rand::rngs::SmallRng::from_seed([1; 32]);
            let mut blobs: Vec<RawBlob> = Vec::new();

            // First blob: V0
            let mut data = vec![0u8; MEDIUM_BATCH_BYTES];
            rng.fill_bytes(&mut data);
            let blob = RawBlob::from(
                celestia_types::Blob::new(ROLLUP_BATCH_NAMESPACE, data, APP_VERSION).unwrap(),
            );
            blobs.push(blob);

            // Second blob: V1, normal
            let mut data = vec![0u8; SMALL_BATCH_BYTES];
            rng.fill_bytes(&mut data);
            let blob = raw_blob_from_data(ROLLUP_BATCH_NAMESPACE, data, signer).unwrap();
            blobs.push(blob);

            // Third, fourth blobs: V0
            for size in [SMALL_BATCH_BYTES, MEDIUM_BATCH_BYTES] {
                let mut data = vec![0u8; size];
                rng.fill_bytes(&mut data);
                let blob = RawBlob::from(
                    celestia_types::Blob::new(ROLLUP_BATCH_NAMESPACE, data, APP_VERSION).unwrap(),
                );
                blobs.push(blob);
            }

            // Only single valid blob, thus 1 signer.
            let signers = serde_json::json!({"signers": vec![signer.to_string(); 1]});
            write_to_file(&path.join(SIGNERS_JSON), &signers).unwrap();

            let block_header = submit_blobs(client, blobs).await.unwrap();

            save_blobs(
                client,
                &path,
                &block_header,
                ROLLUP_BATCH_NAMESPACE,
                ROLLUP_PROOF_NAMESPACE,
            )
            .await;
        }
    }

    fn generate_payload_with_batches(batches: usize, batch_size: usize) -> PayloadData {
        // Not random, but not the same bytes
        let mut rng = rand::rngs::SmallRng::from_seed([1; 32]);
        let mut payload = PayloadData {
            batches: Vec::new(),
            proofs: Vec::new(),
        };
        for _ in 0..batches {
            let mut batch = vec![0u8; batch_size];
            rng.fill_bytes(&mut batch);
            payload.batches.push(hex::encode(batch));
        }
        payload
    }

    fn filtered_block_from_path(
        batch_namespace: Namespace,
        proof_namespace: Namespace,
        path: &Path,
    ) -> anyhow::Result<FilteredCelestiaBlock> {
        let header: ExtendedHeader = load_from_file(path, HEADER_JSON)?;
        let rollup_batch_rows: NamespaceData = load_from_file(path, ROLLUP_BATCH_ROWS_JSON)?;
        let rollup_proof_rows: NamespaceData = load_from_file(path, ROLLUP_PROOF_ROWS_JSON)?;

        let rollup_batch_shares = NamespaceRelevantData::new(batch_namespace, rollup_batch_rows);
        let rollup_proof_shares = NamespaceRelevantData::new(proof_namespace, rollup_proof_rows);

        FilteredCelestiaBlock::new(rollup_batch_shares, rollup_proof_shares, header)
    }

    pub(crate) fn make_test_path(data_path: &str) -> PathBuf {
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        path.push(Path::new(data_path));
        path
    }

    pub(crate) fn load_from_file<T: DeserializeOwned>(
        path: &Path,
        name: &str,
    ) -> anyhow::Result<T> {
        let path = path.join(name);
        let file = File::open(&path).context(format!("Failed to open {}", path.display()))?;
        serde_json::from_reader(file).context(format!("Failed to parse {}", path.display()))
    }

    pub(crate) fn write_to_file<T: serde::Serialize>(path: &Path, data: &T) -> anyhow::Result<()> {
        let pretty_json = serde_json::to_string_pretty(data)?;
        std::fs::write(path, pretty_json)?;
        Ok(())
    }

    pub(crate) fn get_payload_for_test(path: impl AsRef<Path>) -> anyhow::Result<PayloadData> {
        load_from_file(path.as_ref(), "payload.json")
    }

    pub(crate) async fn update_block_data(
        path: &Path,
        client: &jsonrpsee::http_client::HttpClient,
        signer: &CelestiaAddress,
        with_prev_header: bool,
    ) -> anyhow::Result<()> {
        let payload = get_payload_for_test(path)?;
        update_block_data_from_payload(path, client, signer, with_prev_header, payload).await
    }

    pub(crate) async fn update_block_data_from_payload(
        path: &Path,
        client: &jsonrpsee::http_client::HttpClient,
        signer: &CelestiaAddress,
        with_prev_header: bool,
        payload: PayloadData,
    ) -> anyhow::Result<()> {
        let mut blobs: Vec<RawBlob> = Vec::with_capacity(payload.batches.len());

        if !payload.batches.is_empty() || !payload.proofs.is_empty() {
            for batch in &payload.batches {
                let data = hex::decode(batch)?;
                let blob = raw_blob_from_data(ROLLUP_BATCH_NAMESPACE, data, signer)?;
                blobs.push(blob);
            }
            for proof in &payload.proofs {
                let data = hex::decode(proof)?;
                let blob = raw_blob_from_data(ROLLUP_PROOF_NAMESPACE, data, signer)?;
                blobs.push(blob);
            }
        } else {
            let data = vec![0, 1, 2, 3, 4, 5];
            let blob = raw_blob_from_data(ROLLUP_OTHER_NAMESPACE_PRECEDING, data, signer)?;
            blobs.push(blob);
        }

        // All blobs are sent from single signer.
        // But other test blocks might have different case.
        let signers = serde_json::json!({"signers": vec![signer.to_string(); blobs.len()]});
        write_to_file(&path.join(SIGNERS_JSON), &signers)?;

        let block_header = submit_blobs(client, blobs).await?;
        if with_prev_header {
            let prev_block_header = client
                .header_get_by_height(block_header.height().value().checked_sub(1).unwrap())
                .await?;
            write_to_file(&path.join(PREV_HEADER_JSON), &prev_block_header)?;
        }

        save_blobs(
            client,
            path,
            &block_header,
            ROLLUP_BATCH_NAMESPACE,
            ROLLUP_PROOF_NAMESPACE,
        )
        .await;
        Ok(())
    }

    async fn save_blobs(
        client: &jsonrpsee::http_client::HttpClient,
        path: &Path,
        block_header: &ExtendedHeader,
        batch_namespace: Namespace,
        proof_namespace: Namespace,
    ) {
        write_to_file(&path.join(HEADER_JSON), &block_header).unwrap();

        let signers = serde_json::json!({"signers": Vec::<String>::new()});
        write_to_file(&path.join(SIGNERS_JSON), &signers).unwrap();
        let rollup_batch_rows = client
            .share_get_namespace_data(block_header, batch_namespace)
            .await
            .unwrap();
        write_to_file(&path.join(ROLLUP_BATCH_ROWS_JSON), &rollup_batch_rows).unwrap();

        let rollup_proof_rows = client
            .share_get_namespace_data(block_header, proof_namespace)
            .await
            .unwrap();
        write_to_file(&path.join(ROLLUP_PROOF_ROWS_JSON), &rollup_proof_rows).unwrap();
    }

    #[allow(clippy::float_arithmetic)]
    pub(crate) async fn submit_blobs(
        client: &jsonrpsee::http_client::HttpClient,
        blobs: Vec<RawBlob>,
    ) -> anyhow::Result<ExtendedHeader> {
        let tx_config = celestia_rpc::TxConfig::default();

        let tx_response = client.state_submit_pay_for_blob(&blobs, tx_config).await?;
        let height = tx_response.height as u64;

        let block_header = client.header_get_by_height(height).await?;
        Ok(block_header)
    }

    pub(crate) fn read_signers(data_path: impl AsRef<Path>) -> Vec<CelestiaAddress> {
        use std::str::FromStr;
        let signers_path = data_path.as_ref().join(SIGNERS_JSON);
        let signers: serde_json::Value =
            serde_json::from_reader(File::open(signers_path).unwrap()).unwrap();
        let signers: Vec<String> = signers["signers"]
            .as_array()
            .unwrap()
            .iter()
            .map(|s| s.as_str().unwrap().to_string())
            .collect();
        signers
            .iter()
            .map(|s| CelestiaAddress::from_str(s).unwrap())
            .collect()
    }
}

pub(crate) mod serialization {
    use std::num::NonZero;
    use std::str::FromStr;

    use sov_rollup_interface::da::{RelevantBlobs, RelevantProofs};
    use sov_rollup_interface::node::da::DaService;

    use super::*;
    use crate::types::{BlobWithSender, FilteredCelestiaBlock, NamespaceBoundaryProof};
    use crate::verifier::address::CelestiaAddress;
    use crate::verifier::proofs::BlobProof;
    use crate::verifier::RollupParams;
    use crate::{CelestiaConfig, CelestiaService};

    type CelestiaRelevantProofs = RelevantProofs<Vec<BlobProof>, Option<NamespaceBoundaryProof>>;

    pub(crate) async fn get_test_da_service(port: u16) -> CelestiaService {
        CelestiaService::new(
            CelestiaConfig {
                celestia_rpc_auth_token: "TEST".to_string(),
                celestia_rpc_address: format!("http://127.0.0.1:{}", port),
                max_celestia_response_body_size: NonZero::new(100_000).unwrap(),
                celestia_rpc_timeout_seconds: NonZero::new(10).unwrap(),
                signer_address: CelestiaAddress::from_str(ADDR_1).unwrap(),
                safe_lead_time_ms: 500,
            },
            RollupParams {
                rollup_batch_namespace: ROLLUP_BATCH_NAMESPACE,
                rollup_proof_namespace: ROLLUP_PROOF_NAMESPACE,
            },
        )
        .await
    }

    pub(crate) async fn test_block_serialization(
        da_service: &CelestiaService,
        block: FilteredCelestiaBlock,
    ) {
        // Block itself
        let serialized_bincode_block =
            bincode::serialize(&block).expect("block bincode serialization failed");
        let deserialize_bincode_block =
            bincode::deserialize::<FilteredCelestiaBlock>(&serialized_bincode_block)
                .expect("block bincode deserialization failed");
        assert_eq!(block, deserialize_bincode_block);

        let serialized_risc0_block =
            risc0_zkvm::serde::to_vec(&block).expect("block risc0 serialization failed");
        let deserialized_risc0_block: FilteredCelestiaBlock =
            risc0_zkvm::serde::from_slice(&serialized_risc0_block)
                .expect("block risc0 deserialization failed");
        assert_eq!(block, deserialized_risc0_block);

        // Relevant blobs
        let relevant_blobs = da_service.extract_relevant_blobs(&block);

        let serialized_bincode_relevant_blobs = bincode::serialize(&relevant_blobs)
            .expect("relevant blobs bincode serialization failed");
        let deserialized_bincode_relevant_blobs: RelevantBlobs<BlobWithSender> =
            bincode::deserialize(&serialized_bincode_relevant_blobs)
                .expect("relevant blobs bincode deserialization failed");
        assert_eq!(
            relevant_blobs.batch_blobs,
            deserialized_bincode_relevant_blobs.batch_blobs
        );
        assert_eq!(
            relevant_blobs.proof_blobs,
            deserialized_bincode_relevant_blobs.proof_blobs
        );

        let serialized_risc0_relevant_blobs = risc0_zkvm::serde::to_vec(&relevant_blobs)
            .expect("relevant blobs risc0 serialization failed");
        let deserialized_risc0_relevant_blobs: RelevantBlobs<BlobWithSender> =
            risc0_zkvm::serde::from_slice(&serialized_risc0_relevant_blobs)
                .expect("relevant blobs risc0 deserialization failed");

        assert_eq!(
            relevant_blobs.batch_blobs,
            deserialized_risc0_relevant_blobs.batch_blobs
        );
        assert_eq!(
            relevant_blobs.proof_blobs,
            deserialized_risc0_relevant_blobs.proof_blobs
        );

        // Extraction proof
        let extraction_proof = da_service
            .get_extraction_proof(&block, &relevant_blobs)
            .await;

        let serialized_bincode_extraction_proof = bincode::serialize(&extraction_proof)
            .expect("extraction proof bincode serialization failed");
        let deserialized_bincode_extraction_proof: CelestiaRelevantProofs =
            bincode::deserialize(&serialized_bincode_extraction_proof)
                .expect("extraction proof bincode deserialization failed");
        compare_ext_proof(&extraction_proof, &deserialized_bincode_extraction_proof);

        let serialized_risc0_extraction_proof = risc0_zkvm::serde::to_vec(&extraction_proof)
            .expect("extraction proof risc0 serialization failed");
        let deserialized_risc0_extraction_proof: CelestiaRelevantProofs =
            risc0_zkvm::serde::from_slice(&serialized_risc0_extraction_proof)
                .expect("extraction proof risc0 deserialization failed");
        compare_ext_proof(&extraction_proof, &deserialized_risc0_extraction_proof);
    }

    fn compare_ext_proof(expected: &CelestiaRelevantProofs, deserialized: &CelestiaRelevantProofs) {
        assert_eq!(
            expected.proof.inclusion_proof,
            deserialized.proof.inclusion_proof
        );
        assert_eq!(
            expected.proof.completeness_proof,
            deserialized.proof.completeness_proof
        );
        assert_eq!(
            expected.batch.inclusion_proof,
            deserialized.batch.inclusion_proof
        );
        assert_eq!(
            expected.batch.completeness_proof,
            deserialized.batch.completeness_proof
        );
    }
}
