//! A client for the Sovereign SDK ledger JSON API, generated by
//! [`progenitor`].

use std::str::FromStr;
use std::time::Duration;

use anyhow::Context;
use backon::{ExponentialBuilder, Retryable};
use base64::prelude::*;
use borsh::BorshSerialize;
use futures::stream::BoxStream;
use futures::StreamExt;
use sov_modules_api::RawTx;
use sov_rollup_interface::node::ledger_api::{FinalityStatus, IncludeChildren};
use sov_rollup_interface::zk::aggregated_proof;
use sov_rollup_interface::TxHash;
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::{Error as WsError, Message};
use types::AcceptTxResponse;
pub extern crate tokio_tungstenite;

pub type WsSubscription<T> = Result<BoxStream<'static, anyhow::Result<T>>, WsError>;

progenitor::generate_api!(
    spec = "./openapi-v3.yaml",
    derives = [Debug, Clone, PartialEq],
);

/// Custom WebSocket extensions and extra utilities, in addition to the
/// [`Client`] generated by [`progenitor`].
impl Client {
    pub async fn subscribe_slots_with_children(
        &self,
        include_children: IncludeChildren,
    ) -> WsSubscription<types::Slot> {
        self.subscribe_to_ws(&format!(
            "/ledger/slots/latest/ws?children={include_children}"
        ))
        .await
    }

    pub async fn subscribe_slots(&self) -> WsSubscription<types::Slot> {
        self.subscribe_slots_with_children(IncludeChildren::default())
            .await
    }

    pub async fn subscribe_finalized_slots_with_children(
        &self,
        include_children: IncludeChildren,
    ) -> WsSubscription<types::Slot> {
        self.subscribe_to_ws(&format!(
            "/ledger/slots/finalized/ws?children={include_children}"
        ))
        .await
    }

    pub async fn subscribe_finalized_slots(&self) -> WsSubscription<types::Slot> {
        self.subscribe_finalized_slots_with_children(IncludeChildren::default())
            .await
    }

    pub async fn subscribe_aggregated_proof(&self) -> WsSubscription<types::AggregatedProof> {
        self.subscribe_to_ws("/ledger/aggregated-proofs/latest/ws")
            .await
    }

    pub async fn send_tx_to_sequencer<Tx: BorshSerialize>(
        &self,
        tx: &Tx,
    ) -> Result<ResponseValue<AcceptTxResponse>, Error<types::AcceptTxResponse>> {
        let tx_bytes = borsh::to_vec(tx).map_err(|err| Error::InvalidRequest(err.to_string()))?;
        let tx_b64 = BASE64_STANDARD.encode(&tx_bytes);
        self.accept_tx(&types::AcceptTxBody { body: tx_b64 }).await
    }

    pub async fn send_tx_to_sequencer_with_retry<Tx: BorshSerialize>(
        &self,
        tx: &Tx,
    ) -> Result<ResponseValue<AcceptTxResponse>, Error<types::AcceptTxResponse>> {
        let raw_tx =
            RawTx::new(borsh::to_vec(tx).map_err(|err| Error::InvalidRequest(err.to_string()))?);
        self.send_raw_tx_to_sequencer_with_retry(&raw_tx).await
    }

    pub async fn send_raw_tx_to_sequencer_with_retry(
        &self,
        raw_tx: &RawTx,
    ) -> Result<ResponseValue<AcceptTxResponse>, Error<types::AcceptTxResponse>> {
        let tx_b64 = BASE64_STANDARD.encode(raw_tx);
        let backoff = ExponentialBuilder::default()
            .with_factor(1.5)
            .with_min_delay(Duration::from_millis(200))
            .with_max_times(30)
            // With max delay of 15 seconds, the maximal total waiting time is going to be a little bit more than 5 minutes
            .with_max_delay(Duration::from_secs(15));
        let tx = types::AcceptTxBody { body: tx_b64 };
        let client = self.clone();
        let fut = || async { client.accept_tx(&tx).await };
        fut.retry(&backoff)
            .when(|err| {
                match err {
                    Error::InvalidRequest(_) | Error::InvalidUpgrade(_) | Error::PreHookError(_) => false,
                    Error::CommunicationError(_) | Error::ErrorResponse(_) | Error::ResponseBodyError(_) | Error::UnexpectedResponse(_) => true,
                    // This needs further improvement on the generated client.
                    // Details in https://github.com/Sovereign-Labs/sovereign-sdk-wip/pull/2799
                    Error::InvalidResponsePayload(bytes, _error) => {
                        // All non-HTTP 4** are retried.
                        !std::str::from_utf8(bytes.as_ref()).unwrap_or("").contains("\"status\":4")
                    }
                }
            })
            .notify(|err, dur| {
                tracing::warn!(err = ?err, duration = ?dur, "Failed to submit transaction. Retrying...");
            })
            .await
    }

    /// Sends transactions to the sequencer for later publication.
    pub async fn send_txs_to_sequencer<Tx: BorshSerialize>(
        &self,
        txs: &[Tx],
    ) -> Result<Vec<ResponseValue<AcceptTxResponse>>, Error<types::AcceptTxResponse>> {
        let mut receipts = Vec::with_capacity(txs.len());

        for tx in txs {
            let res = self.send_tx_to_sequencer(tx).await?;
            receipts.push(res);
        }

        Ok(receipts)
    }

    pub async fn subscribe_to_tx_status_updates(
        &self,
        tx_hash: TxHash,
    ) -> WsSubscription<types::TxInfo> {
        self.subscribe_to_ws(&format!("/sequencer/txs/{}/ws", tx_hash))
            .await
    }

    async fn subscribe_to_ws<T: serde::de::DeserializeOwned>(
        &self,
        path: &str,
    ) -> WsSubscription<T> {
        // The base URL can't be used for WebSocket connections; we need to
        // change the protocol.
        let url = format!("{}{}", self.baseurl(), path).replace("http://", "ws://");

        let (ws, _) = connect_async(url).await?;

        Ok(ws
            .filter_map(|msg| async {
                match msg {
                    Ok(Message::Text(text)) => match serde_json::from_str(&text) {
                        Ok(tx_status) => Some(Ok(tx_status)),
                        Err(err) => Some(Err(anyhow::anyhow!(
                            "failed to deserialize JSON {} into type: {}",
                            text,
                            err
                        ))),
                    },
                    Ok(Message::Binary(msg)) => {
                        tracing::warn!(
                            ?msg,
                            "Received unsupported binary message from WebSocket connection"
                        );
                        None
                    }
                    // All other kinds of messages are ignored because
                    // `tokio-tungstenite` ought to handle all
                    // meta-communication messages (ping, pong, clonse) for us anyway.
                    Ok(_) => None,
                    // Errors are not handled here but passed to the caller.
                    Err(err) => Some(Err(anyhow::anyhow!("{}", err))),
                }
            })
            .boxed())
    }
}

impl TryInto<aggregated_proof::SerializedAggregatedProof> for types::AggregatedProof {
    type Error = anyhow::Error;

    fn try_into(self) -> anyhow::Result<aggregated_proof::SerializedAggregatedProof> {
        Ok(aggregated_proof::SerializedAggregatedProof {
            raw_aggregated_proof: decode_b64(&self.proof)?,
        })
    }
}

fn decode_b64(data: &str) -> anyhow::Result<Vec<u8>> {
    BASE64_STANDARD
        .decode(data)
        .context("Failed to decode base64 data in aggregated proof response")
}

impl From<types::SlotFinalityStatus> for FinalityStatus {
    fn from(value: types::SlotFinalityStatus) -> Self {
        match value {
            types::SlotFinalityStatus::Finalized => FinalityStatus::Finalized,
            types::SlotFinalityStatus::Pending => FinalityStatus::Pending,
        }
    }
}

impl From<TxHash> for types::TxHash {
    fn from(value: TxHash) -> Self {
        types::TxHash::from_str(&value.to_string()).unwrap()
    }
}
