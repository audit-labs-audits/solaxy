//! Defines the traits that must be implemented by zkVMs. A zkVM like Risc0 consists of two components,
//! a "guest" and a "host". The guest is the zkVM program itself, and the host is the physical machine on
//! which the zkVM is running. Both the guest and the host are required to implement the [`Zkvm`] trait, in
//! addition to the specialized [`ZkvmGuest`] and [`ZkvmHost`] trait which is appropriate to that environment.
//!
//! For a detailed example showing how to implement these traits, see the
//! [risc0 adapter](https://github.com/Sovereign-Labs/sovereign-sdk/tree/main/adapters/risc0)
//! maintained by the Sovereign Labs team.
pub mod aggregated_proof;
use core::fmt::Debug;

use borsh::{BorshDeserialize, BorshSerialize};
use digest::typenum::U32;
use digest::Digest;
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};
#[cfg(feature = "native")]
use sov_universal_wallet::UniversalWallet;

#[cfg(feature = "native")]
use crate as sov_rollup_interface; // Needed for UniversalWallet, as it requires global paths
use crate::crypto::{PublicKey, Signature};
use crate::da::{DaSpec, RelevantBlobs, RelevantProofs};

/// The ZK proof generated by the [`ZkvmHost::run`] method.
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Proof<F, T> {
    /// Only public data was generated.
    PublicData(T),
    /// The serialized ZK proof.
    Full(F),
}

/// The `CryptoSpec` trait configures the cryptographic primitives used by a particular instance of a rollup.
/// this trait implementation is meant to be provided by the `Zkvm`. module
pub trait CryptoSpec: PartialEq + Debug + Clone + Send + Sync + 'static {
    /// The public key used for digital signatures
    #[cfg(feature = "native")]
    type PrivateKey: crate::crypto::PrivateKey<
        PublicKey = Self::PublicKey,
        Signature = Self::Signature,
    >;

    /// The public key used for digital signatures
    type PublicKey: PublicKey;

    /// The hasher preferred by the rollup, such as Sha256 or Poseidon.
    type Hasher: Digest<OutputSize = U32> + Send + Sync + 'static;

    /// The digital signature scheme used by the rollup.
    type Signature: Signature<PublicKey = Self::PublicKey>
        + serde::Serialize
        + for<'a> serde::Deserialize<'a>;
}

/// A complete Zkvm implementation.
pub trait Zkvm: Default + Clone + Send + Sync + 'static {
    /// The verifier for the ZkCircuit
    type Verifier: ZkVerifier;

    /// The guest for the ZkCircuit
    type Guest: ZkvmGuest;

    /// The proof generator. Only available under the `"native"` feature.
    #[cfg(feature = "native")]
    type Host: ZkvmHost<Guest: ZkvmGuest<Verifier = Self::Verifier>>;
}

/// The arguments required by the [`Zkvm::Host`]'s constructor function.
#[cfg(feature = "native")]
pub type HostArgs<Vm> = <<Vm as Zkvm>::Host as ZkvmHost>::HostArgs;

/// The code commitment for the Zkvm
pub type CodeCommitmentFor<Vm> = <<Vm as Zkvm>::Verifier as ZkVerifier>::CodeCommitment;

/// A prover instance for a particular Zkvm program/circuit.
pub trait ZkvmHost: Clone + Send + Sync + 'static {
    /// The associated guest type
    type Guest: ZkvmGuest;

    /// The required arguments to the constructor - usually either a `Vec<u8>`` or a path to the file containing an `ELF`.
    #[cfg(feature = "native")]
    type HostArgs: Send + Sync + 'static + Default;

    /// Constructs a new `ZkvmHost`.
    #[cfg(feature = "native")]
    fn from_args(args: &Self::HostArgs) -> Self;

    /// Give the guest a piece of advice non-deterministically
    fn add_hint<T: Serialize>(&mut self, item: T);

    /// Returns a commitment to the program to be proven. This method does a lot of heavy cryptographic work - caller beware!
    #[cfg(feature = "native")]
    fn code_commitment(
        &self,
    ) -> <<Self::Guest as ZkvmGuest>::Verifier as ZkVerifier>::CodeCommitment;

    /// Run the guest in the true zk environment using the provided hints.
    ///
    /// This runs the guest binary compiled for the zkVM target, optionally
    /// creating a SNARK of correct execution. Running the true guest binary comes
    /// with some mild performance overhead, but it is orders of magnitude less expensive than generating a proof.
    fn run(&mut self, with_proof: bool) -> anyhow::Result<Vec<u8>>;
}

/// A commitment to a zkVM program.
pub trait CodeCommitment:
    Clone + Debug + Serialize + DeserializeOwned + Send + Sync + PartialEq + Eq
{
    /// An error that occurs while trying to decode a commitment.
    type DecodeError: Debug;

    /// Encodes the commitment into a byte sequence. Any kind of serializer may be used,
    /// as long as this method is inverted by the [`CodeCommitment::decode`] method.
    fn encode(&self) -> Vec<u8>;

    /// Decodes the commitment from a byte sequence.
    ///
    /// This method must be the inverse of the [`CodeCommitment::encode`] method.
    fn decode(data: &[u8]) -> Result<Self, Self::DecodeError>;
}

/// A Zk proof system capable of proving and verifying arbitrary Rust code
/// Must support recursive proofs.
pub trait ZkVerifier: Default + Clone + Send + Sync + 'static {
    /// A commitment to the zkVM program which is being proven
    type CodeCommitment: CodeCommitment;

    /// Defines the cryptographic operations provided natively by the Zkvm.
    type CryptoSpec: CryptoSpec;

    /// The error type which is returned when a proof fails to verify
    type Error: Debug;

    /// Interpret a sequence of a bytes as a proof and attempt to verify it against the code commitment.
    /// If the proof is valid, return a public outputs of the proof.
    fn verify<T: DeserializeOwned>(
        serialized_proof: &[u8],
        code_commitment: &Self::CodeCommitment,
    ) -> Result<T, Self::Error>;
}

/// A trait which is accessible from within a zkVM program.
pub trait ZkvmGuest: Send + Sync {
    /// The verifier type associated with this vm.
    type Verifier: ZkVerifier;
    /// Obtain "advice" non-deterministically from the host
    fn read_from_host<T: DeserializeOwned>(&self) -> T;
    /// Add a public output to the zkVM proof
    fn commit<T: Serialize>(&self, item: &T);
}

/// The public output of a SNARK proof in Sovereign, this struct makes a claim that
/// the state of the rollup has transitioned from `initial_state_root` to `final_state_root`.
///
/// The period of time covered by a state transition proof may be a single slot, or a range of slots on the DA layer.
#[derive(Clone, Debug, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[cfg_attr(feature = "native", derive(UniversalWallet))]
pub struct StateTransitionPublicData<Address, Da: DaSpec, Root> {
    /// The state of the rollup before the transition
    #[borsh(bound(
        serialize = "Root: borsh::ser::BorshSerialize",
        deserialize = "Root: borsh::de::BorshDeserialize"
    ))]
    pub initial_state_root: Root,
    /// The state of the rollup after the transition
    #[borsh(bound(
        serialize = "Root: borsh::ser::BorshSerialize",
        deserialize = "Root: borsh::de::BorshDeserialize"
    ))]
    pub final_state_root: Root,
    /// The slot hash of the state transition
    #[borsh(bound(
        serialize = "<Da as DaSpec>::SlotHash: borsh::ser::BorshSerialize",
        deserialize = "<Da as DaSpec>::SlotHash: borsh::de::BorshDeserialize"
    ))]
    pub slot_hash: Da::SlotHash,

    /// Prover address.
    pub prover_address: Address,
}

#[derive(Serialize, Deserialize)]
#[cfg_attr(feature = "native", derive(UniversalWallet))]
// Prevent serde from generating spurious trait bounds. The correct serde bounds are already enforced by the
// StateTransitionFunction, DA, and Zkvm traits.
#[serde(bound = "StateRoot: Serialize + DeserializeOwned, Witness: Serialize + DeserializeOwned")]
/// State transition witness.
pub struct StateTransitionWitness<StateRoot, Witness, Da: DaSpec> {
    /// The state root before the state transition
    pub initial_state_root: StateRoot,
    /// The state root after the state transition
    pub final_state_root: StateRoot,
    /// The header of the da block that is being processed
    pub da_block_header: Da::BlockHeader,
    /// Proofs that the relevant blobs belong to the DA block.
    pub relevant_proofs: RelevantProofs<Da::InclusionMultiProof, Da::CompletenessProof>,
    /// The blobs that are being processed
    pub relevant_blobs: RelevantBlobs<<Da as DaSpec>::BlobTransaction>,
    /// The witness for the state transition
    pub witness: Witness,
}

#[derive(Serialize, Deserialize)]
#[cfg_attr(feature = "native", derive(UniversalWallet))]
#[serde(
    bound = "Address: Serialize + DeserializeOwned, StateRoot: Serialize + DeserializeOwned, Witness: Serialize + DeserializeOwned"
)]
/// Data required to prove a state transition.
pub struct StateTransitionWitnessWithAddress<Address, StateRoot, Witness, Da: DaSpec> {
    /// Witness.
    pub stf_witness: StateTransitionWitness<StateRoot, Witness, Da>,
    /// Prover address.
    pub prover_address: Address,
}
