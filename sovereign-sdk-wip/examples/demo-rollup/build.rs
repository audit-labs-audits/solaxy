use std::fs::File;
use std::io::{self, Write};
use std::os::unix::process::ExitStatusExt;
use std::process::{Command, ExitStatus};

use demo_stf::runtime::{Runtime, RuntimeCall};
use sov_address::MultiAddressEvm;
use sov_mock_da::MockDaSpec;
use sov_mock_zkvm::{MockZkvm, MockZkvmCryptoSpec};
use sov_modules_api::execution_mode::Native;
use sov_modules_api::macros::config_value;
use sov_modules_api::schemars::schema_for;
use sov_modules_api::transaction::{Transaction, UnsignedTransaction};
use sov_modules_api::{Address, CryptoSpec};
use sov_state::{DefaultStorageSpec, ProverStorage};
use sov_universal_wallet::schema::{ChainData, Schema};

type S = sov_modules_api::configurable_spec::ConfigurableSpec<
    MockDaSpec,
    MockZkvm,
    MockZkvm,
    MockZkvmCryptoSpec,
    MultiAddressEvm,
    Native,
    ProverStorage<DefaultStorageSpec<<MockZkvmCryptoSpec as CryptoSpec>::Hasher>>,
>;

fn try_set_commit_hash_env() {
    if let Ok(output) = Command::new("git").args(["rev-parse", "HEAD"]).output() {
        if output.status.success() {
            let hash = String::from_utf8_lossy(&output.stdout).trim().to_string();
            println!("cargo:rustc-env=GIT_COMMIT_HASH={}", hash);
        }
    }
}

fn main() -> io::Result<()> {
    println!("cargo::rerun-if-env-changed=SKIP_GUEST_BUILD");
    println!("cargo::rerun-if-env-changed=SOV_PROVER_MODE");
    println!("cargo::rustc-check-cfg=cfg(skip_guest_build)");

    println!("cargo:rerun-if-changed=NULL");

    let is_risczero_installed = Command::new("cargo")
        .args(["risczero", "help"])
        .status()
        .unwrap_or(ExitStatus::from_raw(1)); // If we can't execute the command, assume risczero isn't installed since duplicate install attempts are no-ops.

    if !is_risczero_installed.success() {
        // If installation fails, just exit silently. The user can try again.
        let _ = Command::new("cargo")
            .args(["install", "cargo-risczero"])
            .status();
    }

    let skip_guest_build = std::env::var("SKIP_GUEST_BUILD").unwrap_or_else(|_| "0".to_string());
    if skip_guest_build == "1" {
        println!("cargo::rustc-cfg=skip_guest_build");
    }

    let schema = Schema::of_rollup_types_with_chain_data::<
        Transaction<Runtime<S>, S>,
        UnsignedTransaction<Runtime<S>, S>,
        RuntimeCall<S>,
        Address,
    >(ChainData {
        chain_id: config_value!("CHAIN_ID"),
        chain_name: config_value!("CHAIN_NAME").to_string(),
    })
    .unwrap();

    let schema_json_string = serde_json::to_string_pretty(&schema)?;
    let mut json_file = File::create("demo-rollup-schema.json")?;
    json_file.write_all(schema_json_string.as_bytes())?;
    json_file.write_all(b"\n")?;

    let borsh_file = File::create("demo-rollup-schema.bin")?;
    borsh::to_writer(borsh_file, &schema)?;

    let chain_hash = schema.cached_chain_hash().unwrap();
    let mut generated_file = File::create("autogenerated.rs")?;
    write!(
        &mut generated_file,
        "pub const CHAIN_HASH: [u8; 32] = {:?};\n\n",
        chain_hash
    )?;
    write!(
        &mut generated_file,
        "#[allow(dead_code)]\npub const SCHEMA_JSON: &str = r#\"{}\"#;\n",
        schema_json_string
    )?;

    // usage with quicktype (after removing invalid empty `NotInstantiable` enum)
    // quicktype -s schema runtime_call.json -o runtime_call.ts
    // Resulting TypeScript file will contain strong types for the runtimes call messages
    let mut runtime_call = File::create("runtime_call.json").unwrap();
    let schema = schema_for!(RuntimeCall<S>);
    let schema_str = serde_json::to_string_pretty(&schema).unwrap();
    runtime_call.write_all(schema_str.as_bytes()).unwrap();
    runtime_call.write_all(b"\n")?;

    try_set_commit_hash_env();

    Ok(())
}
